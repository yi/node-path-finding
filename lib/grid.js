// Generated by CoffeeScript 1.6.3
(function() {
  var Grid;

  Grid = (function() {
    Grid.bytesFrom2DArray = function(width, height, array2d) {
      var buf, byte, byteIndex, col, index, offset, row, x, y, _i, _j, _len, _len1;
      if (isNaN(width) || width <= 0 || isNaN(height) || height <= 0 || !Array.isArray(array2d)) {
        console.log("ERROR [grid$::bytesFrom2DArray] bad arguments, width:" + width + ", height:" + height + ", array2d:" + array2d);
        return null;
      }
      buf = new Buffer(Math.ceil(width * height / 8));
      buf.fill(255);
      for (y = _i = 0, _len = array2d.length; _i < _len; y = ++_i) {
        row = array2d[y];
        for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
          col = row[x];
          if (!Boolean(col)) {
            index = y * width + x;
            byteIndex = index >>> 3;
            offset = 7 - (index % 8);
            byte = buf[byteIndex];
            byte = byte ^ 1 << offset;
            buf[byteIndex] = byte;
          }
        }
      }
      return buf;
    };

    function Grid(width, height, bytes) {
      this.width = width;
      this.height = height;
      this.bytes = bytes;
      if (!(width > 0 && height > 0 && Buffer.isBuffer(bytes))) {
        throw new Error("bad arguments, width:" + width + ", height:" + height + ", bytes:" + bytes);
      }
      if (bytes.length !== Math.ceil(width * height / 8)) {
        throw new Error("bytes length mismatch, width:" + width + ", height:" + height + ", bytes.length:" + bytes.length);
      }
    }

    Grid.prototype.isWalkableAt = function(x, y) {
      var byte, bytePos, index, offset;
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
        return false;
      }
      index = y * this.width + x;
      bytePos = index >>> 3;
      offset = 7 - index % 8;
      byte = this.bytes[bytePos];
      return !Boolean(byte >>> offset & 1);
    };

    Grid.prototype.setWalkableAt = function(x, y, walkable) {
      var byte, bytePos, index, offset;
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
        return false;
      }
      index = y * this.width + x;
      bytePos = index >>> 3;
      offset = 7 - index % 8;
      byte = this.bytes[bytePos];
      if (walkable !== this.isWalkableAt(x, y)) {
        return this.bytes[bytePos] = byte ^ 1 << offset;
      }
    };

    Grid.prototype.getNeighbors = function(x, y, allowDiagonal, dontCrossCorners) {
      var d0, d1, d2, d3, neighbors, s0, s1, s2, s3;
      if (allowDiagonal == null) {
        allowDiagonal = false;
      }
      if (dontCrossCorners == null) {
        dontCrossCorners = false;
      }
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
        return null;
      }
      neighbors = [];
      if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(x << 16 | (y - 1));
        s0 = true;
      }
      if (this.isWalkableAt(x + 1, y)) {
        neighbors.push((x + 1) << 16 | y);
        s1 = true;
      }
      if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(x << 16 | (y + 1));
        s2 = true;
      }
      if (this.isWalkableAt(x - 1, y)) {
        neighbors.push((x - 1) << 16 | y);
        s3 = true;
      }
      if (!allowDiagonal) {
        return neighbors;
      }
      if (dontCrossCorners) {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
      } else {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
      }
      if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push((x - 1) << 16 | (y - 1));
      }
      if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push((x + 1) << 16 | (y - 1));
      }
      if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push((x + 1) << 16 | (y + 1));
      }
      if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push((x - 1) << 16 | (y + 1));
      }
      return neighbors;
    };

    Grid.prototype.getARandomWalkableBrick = function() {
      var x, y;
      while (true) {
        x = (Math.random() * this.width) >>> 0;
        y = (Math.random() * this.height) >>> 0;
        if (this.isWalkableAt(x, y)) {
          return x << 16 | y;
        }
      }
    };

    Grid.prototype.toString = function(startLoc, endLoc, path) {
      var arr, brickLoc, i, markpoints, result, x, y, _i, _j, _k, _len, _ref, _ref1;
      markpoints = {};
      if (Array.isArray(path)) {
        for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
          brickLoc = path[i];
          markpoints[brickLoc] = i % 10;
        }
      }
      if (!isNaN(startLoc)) {
        markpoints[startLoc] = "S";
      }
      if (!isNaN(endLoc)) {
        markpoints[endLoc] = "E";
      }
      result = "[Grid(width=" + this.width + ", height=" + this.height + ")]\nDump: ░=walkable, ▓=blocked";
      for (y = _j = 0, _ref = this.height; _j < _ref; y = _j += 1) {
        arr = [];
        for (x = _k = 0, _ref1 = this.width; _k < _ref1; x = _k += 1) {
          if (markpoints[x << 16 | y] !== void 0) {
            arr.push(markpoints[x << 16 | y]);
          } else {
            arr.push(this.isWalkableAt(x, y) ? "░" : "▓");
          }
        }
        result = result + ("\n" + (arr.join('')));
      }
      return result;
    };

    return Grid;

  })();

  module.exports = Grid;

}).call(this);
